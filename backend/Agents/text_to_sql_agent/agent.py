"""
Main Text-to-SQL Agent orchestrator.
"""

from typing import Optional, Dict, Any, List

from .models import (
    SchemaContext,
    ChatResponse,
    StartSessionResponse,
    SessionState,
    GPTSQLResponse,
)
from .openai_client import TextToSQLOpenAIClient
from .state_manager import session_manager, build_schema_context
from .prompts import generate_sample_questions
from .config import SQL_CONFIG

from database.db_utils import get_dataset, query_dataset


class TextToSQLAgent:
    """Main orchestrator for text-to-SQL operations"""

    def __init__(self):
        self.openai_client = TextToSQLOpenAIClient()

    def start_session(self, dataset_id: str) -> StartSessionResponse:
        """
        Start a new chat session for a dataset

        Args:
            dataset_id: Dataset identifier

        Returns:
            StartSessionResponse with session ID, schema, and sample questions

        Raises:
            ValueError: If dataset not found
        """
        # Verify dataset exists
        dataset = get_dataset(dataset_id)
        if not dataset:
            raise ValueError(f"Dataset not found: {dataset_id}")

        # Build schema context
        schema = build_schema_context(dataset_id)
        if not schema:
            raise ValueError(f"Failed to build schema for dataset: {dataset_id}")

        # Create session
        session = session_manager.create_session(dataset_id, schema)

        # Generate sample questions
        sample_questions = generate_sample_questions(schema)

        print(f"[AGENT] Started session {session.session_id} for dataset {dataset_id}")
        print(f"[AGENT] Schema: {len(schema.columns)} columns, {schema.row_count:,} rows")

        return StartSessionResponse(
            session_id=session.session_id,
            schema=schema,
            sample_questions=sample_questions
        )

    def chat(self, session_id: str, message: str) -> ChatResponse:
        """
        Process a chat message and return SQL + results

        Args:
            session_id: Session identifier
            message: User's natural language question

        Returns:
            ChatResponse with status, SQL, results, or error/clarification

        Raises:
            ValueError: If session not found
        """
        # Get session
        session = session_manager.get_session(session_id)
        if not session:
            raise ValueError(f"Session not found or expired: {session_id}")

        # Update activity
        session_manager.update_activity(session_id)

        # Get conversation history
        messages = session_manager.get_messages(session_id)

        # Add user message to history
        session_manager.add_message(session_id, "user", message)

        # Generate SQL
        gpt_response = self.openai_client.generate_sql(
            question=message,
            schema=session.schema,
            messages=messages
        )

        # Handle clarification needed
        if gpt_response.clarification_needed:
            clarification_msg = gpt_response.clarification_needed
            session_manager.add_message(session_id, "assistant", clarification_msg)

            return ChatResponse(
                status="clarification_needed",
                message=clarification_msg
            )

        # Handle error from GPT
        if gpt_response.error:
            error_msg = gpt_response.error
            session_manager.add_message(session_id, "assistant", f"Error: {error_msg}")

            return ChatResponse(
                status="error",
                message="I couldn't generate a SQL query for that question.",
                error_details=error_msg
            )

        # Handle missing SQL
        if not gpt_response.sql:
            return ChatResponse(
                status="error",
                message="Failed to generate SQL query.",
                error_details="No SQL was generated by the model."
            )

        sql_query = gpt_response.sql
        explanation = gpt_response.explanation or "Query generated successfully."

        # Execute SQL query
        result = self._execute_sql(session.dataset_id, sql_query)

        # Handle execution error with retry
        if not result["success"]:
            retry_response = self._handle_sql_error(
                session=session,
                original_sql=sql_query,
                error_message=result["error"]
            )
            if retry_response:
                return retry_response

            # Retry failed, return error
            error_msg = f"SQL execution failed: {result['error']}"
            session_manager.add_message(session_id, "assistant", error_msg, sql_query)

            return ChatResponse(
                status="error",
                message="The generated query failed to execute.",
                sql_query=sql_query,
                error_details=result["error"]
            )

        # Success - format results
        results_data = self._format_results(result)

        # Add assistant message with SQL
        response_msg = explanation
        if result.get("row_count", 0) == 0:
            response_msg += " The query returned no results."
        else:
            response_msg += f" Found {result['row_count']:,} rows."

        session_manager.add_message(session_id, "assistant", response_msg, sql_query)

        return ChatResponse(
            status="success",
            message=response_msg,
            sql_query=sql_query,
            results=results_data,
            columns=result.get("columns", []),
            row_count=result.get("row_count", 0)
        )

    def _execute_sql(self, dataset_id: str, sql_query: str) -> Dict[str, Any]:
        """
        Execute SQL query on dataset

        Args:
            dataset_id: Dataset identifier
            sql_query: SQL query to execute

        Returns:
            Query result dict with success, data, columns, etc.
        """
        return query_dataset(dataset_id, sql_query)

    def _format_results(self, result: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Format query results as list of dicts

        Args:
            result: Raw query result

        Returns:
            List of row dictionaries
        """
        if not result.get("success") or not result.get("data"):
            return []

        columns = result.get("columns", [])
        data = result.get("data", [])

        # Convert tuples to dicts
        formatted = []
        for row in data:
            row_dict = {}
            for i, col in enumerate(columns):
                value = row[i] if i < len(row) else None
                # Handle special types for JSON serialization
                if value is not None:
                    if hasattr(value, 'isoformat'):
                        value = value.isoformat()
                    elif isinstance(value, (bytes, bytearray)):
                        value = value.decode('utf-8', errors='replace')
                row_dict[col] = value
            formatted.append(row_dict)

        return formatted

    def _handle_sql_error(
        self,
        session: SessionState,
        original_sql: str,
        error_message: str
    ) -> Optional[ChatResponse]:
        """
        Attempt to fix SQL error with GPT retry

        Args:
            session: Current session state
            original_sql: SQL that failed
            error_message: Error from DuckDB

        Returns:
            ChatResponse with fixed results, or None if retry failed
        """
        max_retries = SQL_CONFIG["max_retries"]

        if max_retries <= 0:
            return None

        print(f"[AGENT] Attempting to fix SQL error: {error_message}")

        # Ask GPT to fix the SQL
        fix_response = self.openai_client.fix_sql_error(
            original_sql=original_sql,
            error_message=error_message,
            schema=session.schema
        )

        if fix_response.error or not fix_response.sql:
            print(f"[AGENT] Failed to fix SQL: {fix_response.error}")
            return None

        fixed_sql = fix_response.sql

        # Try executing fixed SQL
        result = self._execute_sql(session.dataset_id, fixed_sql)

        if not result["success"]:
            print(f"[AGENT] Fixed SQL also failed: {result['error']}")
            return None

        # Success with fixed SQL
        results_data = self._format_results(result)
        explanation = fix_response.explanation or "Query was fixed and executed successfully."

        response_msg = f"{explanation} Found {result.get('row_count', 0):,} rows."
        session_manager.add_message(session.session_id, "assistant", response_msg, fixed_sql)

        return ChatResponse(
            status="success",
            message=response_msg,
            sql_query=fixed_sql,
            results=results_data,
            columns=result.get("columns", []),
            row_count=result.get("row_count", 0)
        )

    def get_session_state(self, session_id: str) -> SessionState:
        """
        Get the current state of a session

        Args:
            session_id: Session identifier

        Returns:
            SessionState

        Raises:
            ValueError: If session not found
        """
        session = session_manager.get_session(session_id)
        if not session:
            raise ValueError(f"Session not found or expired: {session_id}")

        return session

    def end_session(self, session_id: str) -> bool:
        """
        End and cleanup a session

        Args:
            session_id: Session identifier

        Returns:
            True if session was deleted
        """
        return session_manager.delete_session(session_id)


# Global agent instance
text_to_sql_agent = TextToSQLAgent()
